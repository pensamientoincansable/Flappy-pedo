<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Flappy Pedo - El Juego</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap');
        
        * {
            font-family: 'Outfit', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #0d0d15 100%);
            min-height: 100vh;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        #gameCanvas {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 0 60px rgba(139, 92, 246, 0.3), 0 0 100px rgba(59, 130, 246, 0.1);
        }
        
        .btn-game {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 50%, #3b82f6 100%);
            border: none;
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
            transition: all 0.2s ease;
            font-weight: 600;
        }
        
        .btn-game:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(139, 92, 246, 0.6);
        }
        
        .btn-game:active {
            transform: translateY(0);
        }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .title-gradient {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 25%, #ef4444 50%, #ec4899 75%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle-glow {
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }
        
        #cropModal {
            backdrop-filter: blur(10px);
        }
        
        .crop-area {
            border: 3px dashed #8b5cf6;
            cursor: move;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
        }
        
        .slider-container input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #6366f1, #8b5cf6);
            outline: none;
        }
        
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .level-indicator {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .fart-btn {
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }
        
        .fart-btn:hover {
            transform: scale(1.05);
        }
        
        .fart-btn.selected {
            border-color: #8b5cf6;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-4">
    <!-- Pantalla de inicio -->
    <div id="startScreen" class="text-center max-w-lg mx-auto">
        <h1 class="text-4xl md:text-6xl font-extrabold title-gradient mb-2 tracking-tight">üöΩ FLAPPY PEDO üí®</h1>
        <p class="text-lg text-purple-300 mb-6 subtitle-glow font-semibold italic">"Que los gases te acompa√±en"</p>
        
        <div class="glass-card rounded-2xl p-4 mb-4">
            <h3 class="text-xl text-white mb-3 font-semibold">üì∏ Personaliza tu rostro</h3>
            <label class="btn-game text-base px-5 py-2 rounded-xl cursor-pointer inline-block text-white">
                Subir Foto
                <input type="file" id="imageInput" accept="image/*" class="hidden">
            </label>
            <p class="text-gray-400 mt-2 text-xs">O juega con el rostro por defecto</p>
            <div id="previewContainer" class="mt-3 hidden">
                <img id="facePreview" class="w-20 h-20 rounded-full mx-auto border-4 border-purple-500 object-cover">
                <p class="text-green-400 mt-1 font-semibold text-sm">‚úì Rostro cargado</p>
            </div>
        </div>
        
        <!-- Selector de sonido de pedo -->
        <div class="glass-card rounded-2xl p-4 mb-4">
            <h3 class="text-xl text-white mb-3 font-semibold">üí® Elige tu flatulencia</h3>
            <div class="grid grid-cols-3 gap-2 mb-2" id="fartSelector">
                <button class="fart-btn selected bg-gradient-to-br from-amber-600 to-amber-800 text-white p-3 rounded-xl text-center" data-fart="classic">
                    <div class="text-2xl">üí®</div>
                    <div class="text-xs mt-1">Cl√°sico</div>
                </button>
                <button class="fart-btn bg-gradient-to-br from-green-600 to-green-800 text-white p-3 rounded-xl text-center" data-fart="wet">
                    <div class="text-2xl">üí¶</div>
                    <div class="text-xs mt-1">H√∫medo</div>
                </button>
                <button class="fart-btn bg-gradient-to-br from-red-600 to-red-800 text-white p-3 rounded-xl text-center" data-fart="thunder">
                    <div class="text-2xl">‚ö°</div>
                    <div class="text-xs mt-1">Trueno</div>
                </button>
                <button class="fart-btn bg-gradient-to-br from-purple-600 to-purple-800 text-white p-3 rounded-xl text-center" data-fart="squeaky">
                    <div class="text-2xl">üé∫</div>
                    <div class="text-xs mt-1">Chill√≥n</div>
                </button>
                <button class="fart-btn bg-gradient-to-br from-yellow-600 to-yellow-800 text-white p-3 rounded-xl text-center" data-fart="bubbly">
                    <div class="text-2xl">ü´ß</div>
                    <div class="text-xs mt-1">Burbujeante</div>
                </button>
                <button class="fart-btn bg-gradient-to-br from-pink-600 to-pink-800 text-white p-3 rounded-xl text-center" data-fart="long">
                    <div class="text-2xl">üå¨Ô∏è</div>
                    <div class="text-xs mt-1">Prolongado</div>
                </button>
            </div>
            <button id="testFartBtn" class="mt-3 bg-gray-700 hover:bg-gray-600 px-4 py-1 rounded-lg text-white text-sm transition-all">
                üîä Probar sonido
            </button>
        </div>
        
        <button id="startBtn" class="btn-game text-xl px-10 py-3 rounded-2xl text-white">
            ¬°JUGAR! üéÆ
        </button>
        
        <div class="mt-4 text-gray-500 text-xs">
            <p>üëÜ Toca r√°pido para saltar | üïπÔ∏è Arrastra para pedo direccional</p>
            <p class="mt-1 text-purple-400">üèÜ 10 niveles | 15 retretes por nivel | ¬°Supera el r√©cord!</p>
        </div>
    </div>
    
    <!-- Canvas del juego -->
    <canvas id="gameCanvas" class="hidden"></canvas>
    
    <!-- UI del juego -->
    <div id="gameUI" class="hidden fixed top-4 left-1/2 -translate-x-1/2 text-center z-40">
        <div class="flex items-center justify-center gap-4 mb-2">
            <div class="level-indicator px-4 py-1 rounded-full text-white font-bold text-lg" id="levelDisplay">Nivel 1</div>
        </div>
        <div class="text-6xl text-white font-extrabold drop-shadow-lg" id="scoreDisplay" style="text-shadow: 0 0 20px rgba(0,0,0,0.8), 0 4px 8px rgba(0,0,0,0.5);">0</div>
    </div>
    
    <!-- Notificaci√≥n de nivel -->
    <div id="levelUpNotification" class="hidden fixed inset-0 flex items-center justify-center z-45 pointer-events-none">
        <div class="text-center animate-bounce">
            <div class="text-6xl mb-2">üéâ</div>
            <div class="text-4xl font-extrabold text-yellow-400" style="text-shadow: 0 0 30px rgba(251, 191, 36, 0.8);" id="levelUpText">¬°NIVEL 2!</div>
            <div class="text-xl text-white mt-2">¬°Velocidad aumentada!</div>
        </div>
    </div>
    
    <!-- Game Over -->
    <div id="gameOverScreen" class="hidden fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="glass-card rounded-3xl p-8 text-center border border-red-500/30">
            <h2 class="text-5xl font-extrabold text-red-500 mb-4">üí© GAME OVER ü§™</h2>
            <p class="text-2xl text-purple-300 mb-2">Nivel alcanzado: <span id="finalLevel" class="text-purple-400 font-bold">1</span></p>
            <p class="text-3xl text-white mb-2">Puntuaci√≥n: <span id="finalScore" class="text-yellow-400 font-bold">0</span></p>
            <p class="text-2xl text-gray-300 mb-6">R√©cord: <span id="highScore" class="text-green-400 font-bold">0</span></p>
            <button id="restartBtn" class="btn-game text-xl px-8 py-3 rounded-xl text-white">
                üîÑ Reintentar
            </button>
            <br>
            <button id="menuBtn" class="mt-4 bg-gray-700 hover:bg-gray-600 text-lg px-6 py-2 rounded-xl text-white transition-all">
                üè† Men√∫
            </button>
        </div>
    </div>
    
    <!-- Modal de recorte -->
    <div id="cropModal" class="hidden fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-4">
        <div class="glass-card rounded-3xl p-6 max-w-lg w-full max-h-[90vh] overflow-y-auto">
            <h3 class="text-2xl text-white mb-4 text-center font-semibold">‚úÇÔ∏è Recorta tu rostro</h3>
            
            <div class="relative overflow-hidden bg-gray-900 rounded-xl mb-4" id="cropContainer" style="height: 300px;">
                <canvas id="cropCanvas" class="absolute"></canvas>
                <div id="cropCircle" class="crop-area absolute rounded-full"></div>
            </div>
            
            <div class="space-y-4 mb-4">
                <div class="slider-container">
                    <label class="text-white text-sm mb-1 block">üîç Zoom de imagen</label>
                    <input type="range" id="zoomSlider" min="50" max="200" value="100">
                    <div class="flex justify-between text-gray-400 text-xs mt-1">
                        <span>50%</span>
                        <span id="zoomValue" class="text-purple-400">100%</span>
                        <span>200%</span>
                    </div>
                </div>
                
                <div class="slider-container">
                    <label class="text-white text-sm mb-1 block">‚≠ï Tama√±o del recorte</label>
                    <input type="range" id="sizeSlider" min="80" max="200" value="150">
                    <div class="flex justify-between text-gray-400 text-xs mt-1">
                        <span>Peque√±o</span>
                        <span id="sizeValue" class="text-purple-400">150px</span>
                        <span>Grande</span>
                    </div>
                </div>
            </div>
            
            <div class="flex justify-center gap-4">
                <button id="cancelCrop" class="bg-red-600 hover:bg-red-500 px-6 py-2 rounded-xl text-white text-lg font-semibold transition-all">
                    ‚úï Cancelar
                </button>
                <button id="confirmCrop" class="btn-game px-6 py-2 rounded-xl text-white text-lg font-semibold">
                    ‚úì Confirmar
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURACI√ìN DEL JUEGO =====
        const CONFIG = {
            // Gravedad muy reducida y progresiva
            baseGravity: 0.12,
            gravity: 0.12,
            gravityIncrement: 0.008,
            
            // Fuerza de impulso base
            baseImpulse: 8,
            impulseForce: 8,
            
            // Espacio MUCHO m√°s grande entre obst√°culos
            pipeGap: 220,
            pipeWidth: 70,
            
            // Velocidad inicial muy lenta
            initialSpeed: 1.0,
            baseSpeed: 1.0,
            pipeSpeed: 1.0,
            speedIncrement: 0.15,
            
            spawnInterval: 2800,
            pipesPerLevel: 15,
            maxLevel: 10,
            
            // Joystick
            joystickRadius: 60,
            joystickKnobRadius: 25
        };

        // ===== VARIABLES GLOBALES =====
        let canvas, ctx;
        let gameState = 'menu';
        let score = 0;
        let level = 1;
        let totalPipesPassed = 0;
        let highScore = parseInt(localStorage.getItem('flappyPedoHighScore')) || 0;
        let customFace = null;
        let audioContext = null;
        let animationId = null;
        let selectedFart = 'classic';

        // Estado del jugador - m√°s peque√±o
        const player = {
            x: -80,
            y: 250,
            width: 70,
            height: 85,
            velocityX: 0,
            velocityY: 0,
            rotation: 0,
            isDead: false,
            fartClouds: []
        };

        // Joystick virtual
        const joystick = {
            active: false,
            baseX: 0,
            baseY: 0,
            knobX: 0,
            knobY: 0,
            angle: 0,
            power: 0,
            visible: false
        };

        // Fondo urbano animado
        const cityscape = {
            buildings: [],
            clouds: [],
            birds: [],
            scrollX: 0,
            initialized: false,
            windowStates: [] // Estados de ventanas para parpadeo lento
        };
        
        // Control de toque para distinguir tap vs drag
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        let isTap = false;

        // Obst√°culos y efectos
        let pipes = [];
        let meltingDrops = [];
        let lastPipeSpawn = 0;
        let pipeCounter = 0;
        let animationTime = 0;

        // Animaci√≥n de puerta
        let doorAnimation = {
            active: false,
            progress: 0,
            doorOpen: 0,
            playerEntered: false
        };

        // ===== SISTEMA DE AUDIO =====
        const Audio = {
            init() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            
            playFart(type = selectedFart) {
                this.init();
                
                switch(type) {
                    case 'classic':
                        this.playClassicFart();
                        break;
                    case 'wet':
                        this.playWetFart();
                        break;
                    case 'thunder':
                        this.playThunderFart();
                        break;
                    case 'squeaky':
                        this.playSqueakyFart();
                        break;
                    case 'bubbly':
                        this.playBubblyFart();
                        break;
                    case 'long':
                        this.playLongFart();
                        break;
                }
            },
            
            playClassicFart() {
                const duration = 0.15 + Math.random() * 0.1;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80 + Math.random() * 30, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + duration);
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                osc.connect(filter).connect(gain).connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + duration);
            },
            
            playWetFart() {
                const duration = 0.25;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(60, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + duration);
                
                filter.type = 'lowpass';
                filter.frequency.value = 150;
                filter.Q.value = 5;
                
                gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                const bufferSize = audioContext.sampleRate * duration;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                const noiseGain = audioContext.createGain();
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 800;
                noiseGain.gain.setValueAtTime(0.08, audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                osc.connect(filter).connect(gain).connect(audioContext.destination);
                noise.connect(noiseFilter).connect(noiseGain).connect(audioContext.destination);
                
                osc.start();
                noise.start();
                osc.stop(audioContext.currentTime + duration);
                noise.stop(audioContext.currentTime + duration);
            },
            
            playThunderFart() {
                const duration = 0.3;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(50, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(25, audioContext.currentTime + duration);
                
                filter.type = 'lowpass';
                filter.frequency.value = 100;
                
                gain.gain.setValueAtTime(0.4, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                const sub = audioContext.createOscillator();
                const subGain = audioContext.createGain();
                sub.type = 'sine';
                sub.frequency.value = 35;
                subGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                subGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                osc.connect(filter).connect(gain).connect(audioContext.destination);
                sub.connect(subGain).connect(audioContext.destination);
                
                osc.start();
                sub.start();
                osc.stop(audioContext.currentTime + duration);
                sub.stop(audioContext.currentTime + duration);
            },
            
            playSqueakyFart() {
                const duration = 0.12;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400 + Math.random() * 200, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + duration);
                
                gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                const vibrato = audioContext.createOscillator();
                const vibratoGain = audioContext.createGain();
                vibrato.frequency.value = 30;
                vibratoGain.gain.value = 50;
                vibrato.connect(vibratoGain).connect(osc.frequency);
                
                osc.connect(gain).connect(audioContext.destination);
                
                osc.start();
                vibrato.start();
                osc.stop(audioContext.currentTime + duration);
                vibrato.stop(audioContext.currentTime + duration);
            },
            
            // Nuevo: Pedo burbujeante realista
            playBubblyFart() {
                const duration = 0.4;
                const bubbles = 6 + Math.floor(Math.random() * 4);
                
                for (let i = 0; i < bubbles; i++) {
                    const delay = i * (duration / bubbles) * (0.8 + Math.random() * 0.4);
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        const baseFreq = 60 + Math.random() * 40;
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.7, audioContext.currentTime + 0.08);
                        
                        filter.type = 'lowpass';
                        filter.frequency.value = 150 + Math.random() * 100;
                        filter.Q.value = 2;
                        
                        gain.gain.setValueAtTime(0.15 + Math.random() * 0.1, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                        
                        osc.connect(filter).connect(gain).connect(audioContext.destination);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.08);
                    }, delay * 1000);
                }
            },
            
            // Nuevo: Pedo prolongado realista
            playLongFart() {
                const duration = 0.5 + Math.random() * 0.2;
                const osc = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                // Oscilador principal
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(70, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(50, audioContext.currentTime + duration * 0.3);
                osc.frequency.linearRampToValueAtTime(65, audioContext.currentTime + duration * 0.6);
                osc.frequency.exponentialRampToValueAtTime(35, audioContext.currentTime + duration);
                
                // Segundo oscilador para textura
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(75, audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + duration);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);
                filter.frequency.linearRampToValueAtTime(100, audioContext.currentTime + duration);
                filter.Q.value = 3;
                
                // Envolvente con variaciones
                gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + duration * 0.2);
                gain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + duration * 0.5);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                // Vibrato para hacerlo m√°s realista
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 8 + Math.random() * 4;
                lfoGain.gain.value = 10;
                lfo.connect(lfoGain).connect(osc.frequency);
                
                osc.connect(filter).connect(gain).connect(audioContext.destination);
                osc2.connect(filter);
                
                osc.start();
                osc2.start();
                lfo.start();
                osc.stop(audioContext.currentTime + duration);
                osc2.stop(audioContext.currentTime + duration);
                lfo.stop(audioContext.currentTime + duration);
            },
            
            playLevelUp() {
                this.init();
                [523, 659, 784, 1047].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        osc.connect(gain).connect(audioContext.destination);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.15);
                    }, i * 80);
                });
            },
            
            playDeath() {
                this.init();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(350, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.4);
                gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                osc.connect(gain).connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.4);
            },
            
            playDoorOpen() {
                this.init();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                osc.connect(gain).connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.3);
            }
        };

        // ===== PAISAJE URBANO =====
        const Cityscape = {
            init() {
                if (cityscape.initialized) return;
                
                for (let i = 0; i < 15; i++) {
                    const numWindows = Math.floor(Math.random() * 8) + 3;
                    const numRows = Math.floor(Math.random() * 5) + 3;
                    
                    // Crear estados de ventanas (encendida/apagada) con tiempos de cambio
                    const windowStates = [];
                    for (let r = 0; r < numRows; r++) {
                        windowStates[r] = [];
                        for (let c = 0; c < numWindows; c++) {
                            windowStates[r][c] = {
                                lit: Math.random() > 0.3,
                                nextChange: Date.now() + 5000 + Math.random() * 15000 // Cambio cada 5-20 segundos
                            };
                        }
                    }
                    
                    cityscape.buildings.push({
                        x: i * 80 - 100,
                        width: 50 + Math.random() * 40,
                        height: 100 + Math.random() * 150,
                        color: this.randomBuildingColor(),
                        windows: numWindows,
                        windowRows: numRows,
                        windowStates: windowStates,
                        layer: Math.random() > 0.5 ? 'back' : 'front'
                    });
                }
                
                for (let i = 0; i < 6; i++) {
                    cityscape.clouds.push({
                        x: Math.random() * 500,
                        y: 20 + Math.random() * 60,
                        size: 20 + Math.random() * 30,
                        speed: 0.2 + Math.random() * 0.3
                    });
                }
                
                for (let i = 0; i < 4; i++) {
                    cityscape.birds.push({
                        x: Math.random() * 400,
                        y: 30 + Math.random() * 80,
                        wingPhase: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 0.5
                    });
                }
                
                cityscape.initialized = true;
            },
            
            randomBuildingColor() {
                const colors = ['#1e293b', '#334155', '#475569', '#374151', '#4b5563', '#1f2937'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            update() {
                cityscape.clouds.forEach(cloud => {
                    cloud.x -= cloud.speed * 0.5;
                    if (cloud.x < -50) cloud.x = canvas.width + 50;
                });
                
                cityscape.birds.forEach(bird => {
                    bird.x -= bird.speed;
                    bird.wingPhase += 0.3;
                    if (bird.x < -20) {
                        bird.x = canvas.width + 20;
                        bird.y = 30 + Math.random() * 80;
                    }
                });
                
                if (gameState === 'playing') {
                    cityscape.scrollX += CONFIG.pipeSpeed * 0.3;
                }
            },
            
            draw() {
                const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                skyGradient.addColorStop(0, '#fef3c7');
                skyGradient.addColorStop(0.3, '#fde68a');
                skyGradient.addColorStop(0.6, '#fbbf24');
                skyGradient.addColorStop(1, '#f97316');
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fef08a';
                ctx.beginPath();
                ctx.arc(canvas.width - 60, 50, 35, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fde047';
                ctx.beginPath();
                ctx.arc(canvas.width - 60, 50, 25, 0, Math.PI * 2);
                ctx.fill();
                
                cityscape.clouds.forEach(cloud => {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.size * 0.6, cloud.y - cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
                    ctx.arc(cloud.x - cloud.size * 0.5, cloud.y + cloud.size * 0.1, cloud.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                cityscape.buildings.filter(b => b.layer === 'back').forEach(building => {
                    const x = ((building.x - cityscape.scrollX * 0.3) % (canvas.width + 200)) - 100;
                    this.drawBuilding(x, building, 0.6);
                });
                
                cityscape.buildings.filter(b => b.layer === 'front').forEach(building => {
                    const x = ((building.x - cityscape.scrollX * 0.5) % (canvas.width + 200)) - 100;
                    this.drawBuilding(x, building, 1);
                });
                
                cityscape.birds.forEach(bird => {
                    ctx.fillStyle = '#1e293b';
                    ctx.beginPath();
                    const wingY = Math.sin(bird.wingPhase) * 3;
                    ctx.moveTo(bird.x, bird.y);
                    ctx.quadraticCurveTo(bird.x - 5, bird.y - 3 + wingY, bird.x - 10, bird.y + wingY);
                    ctx.quadraticCurveTo(bird.x + 5, bird.y - 3 + wingY, bird.x + 10, bird.y + wingY);
                    ctx.fill();
                });
            },
            
            drawBuilding(x, building, alpha) {
                const baseY = canvas.height - 20;
                const y = baseY - building.height;
                const now = Date.now();
                
                ctx.fillStyle = building.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(x, y, building.width, building.height);
                
                const windowWidth = 6;
                const windowHeight = 8;
                const windowSpacingX = building.width / (building.windows + 1);
                const windowSpacingY = building.height / (building.windowRows + 1);
                
                for (let row = 0; row < building.windowRows; row++) {
                    for (let col = 0; col < building.windows; col++) {
                        const wx = x + (col + 1) * windowSpacingX - windowWidth / 2;
                        const wy = y + (row + 1) * windowSpacingY - windowHeight / 2;
                        
                        // Actualizar estado de ventana si es momento
                        const windowState = building.windowStates[row][col];
                        if (now > windowState.nextChange) {
                            windowState.lit = !windowState.lit;
                            // Pr√≥ximo cambio en 8-25 segundos (muy lento)
                            windowState.nextChange = now + 8000 + Math.random() * 17000;
                        }
                        
                        if (windowState.lit) {
                            ctx.fillStyle = '#fef08a';
                        } else {
                            ctx.fillStyle = '#1e293b';
                        }
                        ctx.fillRect(wx, wy, windowWidth, windowHeight);
                    }
                }
                
                ctx.globalAlpha = 1;
            }
        };

        // ===== MANEJO DE IMAGEN =====
        const ImageCropper = {
            uploadedImage: null,
            cropPosition: { x: 75, y: 75 },
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            currentZoom: 100,
            cropSize: 150,
            imageOffset: { x: 0, y: 0 },
            
            init() {
                const imageInput = document.getElementById('imageInput');
                const cropCircle = document.getElementById('cropCircle');
                const zoomSlider = document.getElementById('zoomSlider');
                const sizeSlider = document.getElementById('sizeSlider');
                
                imageInput.addEventListener('change', (e) => this.handleImageUpload(e));
                
                zoomSlider.addEventListener('input', (e) => {
                    this.currentZoom = parseInt(e.target.value);
                    document.getElementById('zoomValue').textContent = this.currentZoom + '%';
                    this.updateCanvas();
                });
                
                sizeSlider.addEventListener('input', (e) => {
                    this.cropSize = parseInt(e.target.value);
                    document.getElementById('sizeValue').textContent = this.cropSize + 'px';
                    const cropCanvas = document.getElementById('cropCanvas');
                    this.cropPosition = {
                        x: (cropCanvas.width - this.cropSize) / 2,
                        y: (cropCanvas.height - this.cropSize) / 2
                    };
                    this.updateCanvas();
                });
                
                cropCircle.addEventListener('mousedown', (e) => this.startDrag(e));
                cropCircle.addEventListener('touchstart', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('touchmove', (e) => this.drag(e));
                document.addEventListener('mouseup', () => this.endDrag());
                document.addEventListener('touchend', () => this.endDrag());
                
                document.getElementById('cancelCrop').addEventListener('click', () => {
                    document.getElementById('cropModal').classList.add('hidden');
                    this.imageOffset = { x: 0, y: 0 };
                });
                
                document.getElementById('confirmCrop').addEventListener('click', () => this.confirmCrop());
            },
            
            handleImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    this.uploadedImage = new Image();
                    this.uploadedImage.onload = () => this.showModal();
                    this.uploadedImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            },
            
            showModal() {
                document.getElementById('cropModal').classList.remove('hidden');
                this.currentZoom = 100;
                this.cropSize = 150;
                document.getElementById('zoomSlider').value = 100;
                document.getElementById('sizeSlider').value = 150;
                document.getElementById('zoomValue').textContent = '100%';
                document.getElementById('sizeValue').textContent = '150px';
                this.updateCanvas();
            },
            
            updateCanvas() {
                const container = document.getElementById('cropContainer');
                const cropCanvas = document.getElementById('cropCanvas');
                const cropCtx = cropCanvas.getContext('2d');
                const cropCircle = document.getElementById('cropCircle');
                
                const containerWidth = container.offsetWidth;
                const containerHeight = 300;
                
                const baseScale = Math.min(containerWidth / this.uploadedImage.width, containerHeight / this.uploadedImage.height);
                const scale = baseScale * (this.currentZoom / 100);
                
                cropCanvas.width = containerWidth;
                cropCanvas.height = containerHeight;
                
                const imgWidth = this.uploadedImage.width * scale;
                const imgHeight = this.uploadedImage.height * scale;
                const imgX = (containerWidth - imgWidth) / 2 + this.imageOffset.x;
                const imgY = (containerHeight - imgHeight) / 2 + this.imageOffset.y;
                
                cropCtx.fillStyle = '#1a1a2e';
                cropCtx.fillRect(0, 0, containerWidth, containerHeight);
                cropCtx.drawImage(this.uploadedImage, imgX, imgY, imgWidth, imgHeight);
                
                cropCircle.style.width = this.cropSize + 'px';
                cropCircle.style.height = this.cropSize + 'px';
                
                if (this.cropPosition.x === 75 && this.cropPosition.y === 75) {
                    this.cropPosition = {
                        x: (containerWidth - this.cropSize) / 2,
                        y: (containerHeight - this.cropSize) / 2
                    };
                }
                
                this.cropPosition.x = Math.max(0, Math.min(containerWidth - this.cropSize, this.cropPosition.x));
                this.cropPosition.y = Math.max(0, Math.min(containerHeight - this.cropSize, this.cropPosition.y));
                
                cropCircle.style.left = this.cropPosition.x + 'px';
                cropCircle.style.top = this.cropPosition.y + 'px';
            },
            
            startDrag(e) {
                this.isDragging = true;
                const rect = document.getElementById('cropCircle').getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                this.dragOffset = { x: clientX - rect.left, y: clientY - rect.top };
            },
            
            drag(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                
                const container = document.getElementById('cropContainer');
                const cropCanvas = document.getElementById('cropCanvas');
                const rect = container.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                this.cropPosition.x = Math.max(0, Math.min(cropCanvas.width - this.cropSize, clientX - rect.left - this.dragOffset.x));
                this.cropPosition.y = Math.max(0, Math.min(cropCanvas.height - this.cropSize, clientY - rect.top - this.dragOffset.y));
                
                document.getElementById('cropCircle').style.left = this.cropPosition.x + 'px';
                document.getElementById('cropCircle').style.top = this.cropPosition.y + 'px';
            },
            
            endDrag() {
                this.isDragging = false;
            },
            
            confirmCrop() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 150;
                tempCanvas.height = 150;
                const tempCtx = tempCanvas.getContext('2d');
                
                const container = document.getElementById('cropContainer');
                const containerWidth = container.offsetWidth;
                const containerHeight = 300;
                
                const baseScale = Math.min(containerWidth / this.uploadedImage.width, containerHeight / this.uploadedImage.height);
                const scale = baseScale * (this.currentZoom / 100);
                
                const imgWidth = this.uploadedImage.width * scale;
                const imgHeight = this.uploadedImage.height * scale;
                const imgX = (containerWidth - imgWidth) / 2 + this.imageOffset.x;
                const imgY = (containerHeight - imgHeight) / 2 + this.imageOffset.y;
                
                const sourceX = (this.cropPosition.x - imgX) / scale;
                const sourceY = (this.cropPosition.y - imgY) / scale;
                const sourceSize = this.cropSize / scale;
                
                tempCtx.beginPath();
                tempCtx.arc(75, 75, 75, 0, Math.PI * 2);
                tempCtx.clip();
                tempCtx.drawImage(this.uploadedImage, sourceX, sourceY, sourceSize, sourceSize, 0, 0, 150, 150);
                
                customFace = new Image();
                customFace.src = tempCanvas.toDataURL();
                
                document.getElementById('facePreview').src = customFace.src;
                document.getElementById('previewContainer').classList.remove('hidden');
                document.getElementById('cropModal').classList.add('hidden');
                this.imageOffset = { x: 0, y: 0 };
            }
        };

        // ===== SISTEMA DE NIVELES =====
        const LevelSystem = {
            checkLevelUp() {
                const newLevel = Math.min(CONFIG.maxLevel, Math.floor(totalPipesPassed / CONFIG.pipesPerLevel) + 1);
                
                if (newLevel > level) {
                    level = newLevel;
                    CONFIG.pipeSpeed = CONFIG.baseSpeed + (level - 1) * CONFIG.speedIncrement;
                    CONFIG.gravity = CONFIG.baseGravity + (level - 1) * CONFIG.gravityIncrement;
                    Audio.playLevelUp();
                    this.showNotification();
                    this.updateDisplay();
                }
            },
            
            showNotification() {
                const notification = document.getElementById('levelUpNotification');
                document.getElementById('levelUpText').textContent = `¬°NIVEL ${level}!`;
                notification.classList.remove('hidden');
                setTimeout(() => notification.classList.add('hidden'), 2000);
            },
            
            updateDisplay() {
                document.getElementById('levelDisplay').textContent = `Nivel ${level}`;
            },
            
            isCheckpoint(pipeNumber) {
                return pipeNumber % CONFIG.pipesPerLevel === 0 && pipeNumber > 0;
            }
        };

        // ===== JOYSTICK =====
        const Joystick = {
            getCanvasCoords(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            },
            
            start(e) {
                if (gameState !== 'playing' || player.isDead) return;
                
                const coords = this.getCanvasCoords(e);
                joystick.active = true;
                joystick.visible = true;
                joystick.baseX = coords.x;
                joystick.baseY = coords.y;
                joystick.knobX = coords.x;
                joystick.knobY = coords.y;
                joystick.power = 0;
            },
            
            move(e) {
                if (!joystick.active) return;
                e.preventDefault();
                
                const coords = this.getCanvasCoords(e);
                
                const dx = coords.x - joystick.baseX;
                const dy = coords.y - joystick.baseY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const maxDistance = CONFIG.joystickRadius;
                
                if (distance <= maxDistance) {
                    joystick.knobX = coords.x;
                    joystick.knobY = coords.y;
                } else {
                    const angle = Math.atan2(dy, dx);
                    joystick.knobX = joystick.baseX + Math.cos(angle) * maxDistance;
                    joystick.knobY = joystick.baseY + Math.sin(angle) * maxDistance;
                }
                
                joystick.power = Math.min(distance / maxDistance, 1);
                joystick.angle = Math.atan2(joystick.knobY - joystick.baseY, joystick.knobX - joystick.baseX);
            },
            
            end() {
                if (!joystick.active) return;
                
                if (joystick.power > 0.2) {
                    // Impulsar en direcci√≥n OPUESTA al joystick
                    const impulseX = -Math.cos(joystick.angle) * CONFIG.impulseForce * joystick.power;
                    const impulseY = -Math.sin(joystick.angle) * CONFIG.impulseForce * joystick.power;
                    
                    player.velocityX += impulseX * 0.5;
                    player.velocityY += impulseY;
                    
                    // Limitar velocidades
                    player.velocityX = Math.max(-5, Math.min(5, player.velocityX));
                    player.velocityY = Math.max(-12, Math.min(12, player.velocityY));
                    
                    Audio.playFart();
                    
                    // Crear nube de pedo en la direcci√≥n del joystick
                    const fartAngle = joystick.angle;
                    player.fartClouds.push({
                        x: player.x + player.width / 2 + Math.cos(fartAngle) * 30,
                        y: player.y + player.height / 2 + Math.sin(fartAngle) * 30,
                        angle: fartAngle,
                        size: 15 + joystick.power * 15,
                        opacity: 1,
                        particles: Array.from({length: 8}, () => ({
                            x: 0,
                            y: 0,
                            size: 5 + Math.random() * 10,
                            speed: 2 + Math.random() * 3,
                            angle: fartAngle + (Math.random() - 0.5) * 0.5
                        }))
                    });
                }
                
                joystick.active = false;
                joystick.visible = false;
                joystick.power = 0;
            },
            
            draw() {
                if (!joystick.visible) return;
                
                // Base del joystick
                ctx.beginPath();
                ctx.arc(joystick.baseX, joystick.baseY, CONFIG.joystickRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // L√≠nea de direcci√≥n
                if (joystick.power > 0.1) {
                    ctx.beginPath();
                    ctx.moveTo(joystick.baseX, joystick.baseY);
                    ctx.lineTo(joystick.knobX, joystick.knobY);
                    ctx.strokeStyle = `rgba(139, 92, 246, ${0.5 + joystick.power * 0.5})`;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    // Flecha indicando direcci√≥n de impulso (opuesta)
                    const arrowAngle = joystick.angle + Math.PI;
                    const arrowLength = 30 + joystick.power * 20;
                    const arrowX = joystick.baseX + Math.cos(arrowAngle) * arrowLength;
                    const arrowY = joystick.baseY + Math.sin(arrowAngle) * arrowLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(joystick.baseX, joystick.baseY);
                    ctx.lineTo(arrowX, arrowY);
                    ctx.strokeStyle = `rgba(34, 197, 94, ${0.5 + joystick.power * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Punta de flecha
                    const headLength = 10;
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - Math.cos(arrowAngle - 0.4) * headLength, arrowY - Math.sin(arrowAngle - 0.4) * headLength);
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - Math.cos(arrowAngle + 0.4) * headLength, arrowY - Math.sin(arrowAngle + 0.4) * headLength);
                    ctx.stroke();
                }
                
                // Knob del joystick
                ctx.beginPath();
                ctx.arc(joystick.knobX, joystick.knobY, CONFIG.joystickKnobRadius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(joystick.knobX, joystick.knobY, 0, joystick.knobX, joystick.knobY, CONFIG.joystickKnobRadius);
                gradient.addColorStop(0, `rgba(139, 92, 246, ${0.8 + joystick.power * 0.2})`);
                gradient.addColorStop(1, `rgba(99, 102, 241, ${0.6 + joystick.power * 0.4})`);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Indicador de potencia
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Outfit';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(joystick.power * 100)}%`, joystick.baseX, joystick.baseY - CONFIG.joystickRadius - 10);
            }
        };

        // ===== RENDERIZADO =====
        const Renderer = {
            drawBackground() {
                Cityscape.draw();
                this.drawWindowFrame();
                this.drawFloor();
            },
            
            drawWindowFrame() {
                const frameWidth = 12;
                const windowY = 0;
                const windowHeight = canvas.height - 60;
                
                ctx.fillStyle = '#78350f';
                ctx.fillRect(0, windowY, frameWidth, windowHeight);
                ctx.fillRect(canvas.width - frameWidth, windowY, frameWidth, windowHeight);
                ctx.fillRect(0, windowY, canvas.width, frameWidth);
                ctx.fillRect(0, windowHeight - frameWidth, canvas.width, frameWidth);
                
                ctx.fillRect(canvas.width / 2 - 3, windowY, 6, windowHeight);
                ctx.fillRect(0, windowHeight / 2 - 3, canvas.width, 6);
                
                ctx.strokeStyle = '#92400e';
                ctx.lineWidth = 2;
                ctx.strokeRect(frameWidth, frameWidth, canvas.width - frameWidth * 2, windowHeight - frameWidth * 2);
                
                ctx.fillStyle = '#e0f2fe';
                ctx.fillRect(0, windowHeight, canvas.width, canvas.height - windowHeight);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                const tileSize = 25;
                for (let x = 0; x < canvas.width; x += tileSize) {
                    for (let y = windowHeight; y < canvas.height; y += tileSize) {
                        ctx.strokeRect(x, y, tileSize, tileSize);
                    }
                }
            },
            
            drawFloor() {
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(0, canvas.height - 15, canvas.width, 15);
                ctx.fillStyle = '#334155';
                ctx.fillRect(0, canvas.height - 18, canvas.width, 3);
            },
            
            drawDoor() {
                const doorX = 15;
                const doorY = canvas.height - 180;
                const doorWidth = 65;
                const doorHeight = 150;
                
                ctx.fillStyle = '#78350f';
                ctx.fillRect(doorX - 6, doorY - 6, doorWidth + 12, doorHeight + 6);
                
                const openAmount = doorAnimation.doorOpen * doorWidth * 0.8;
                
                ctx.fillStyle = '#a16207';
                ctx.fillRect(doorX + openAmount, doorY, doorWidth - openAmount, doorHeight);
                
                if (openAmount > 5) {
                    ctx.fillStyle = '#1c1917';
                    ctx.fillRect(doorX, doorY, Math.min(openAmount, doorWidth - 10), doorHeight);
                }
                
                if (doorWidth - openAmount > 12) {
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(doorX + openAmount + doorWidth - openAmount - 12, doorY + doorHeight / 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(doorX + openAmount + 12, doorY + 15, 40 - openAmount * 0.5, 25);
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 14px Outfit';
                ctx.textAlign = 'center';
                if (doorWidth - openAmount > 35) {
                    ctx.fillText('WC', doorX + openAmount + 32, doorY + 33);
                }
                ctx.textAlign = 'left';
            },
            
            drawReadyMessage() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Outfit';
                ctx.textAlign = 'center';
                ctx.fillText('üëÜ TOCA PARA EMPEZAR üëÜ', canvas.width / 2, canvas.height / 2 - 30);
                
                ctx.font = '16px Outfit';
                ctx.fillStyle = '#fbbf24';
                ctx.fillText('Toca r√°pido para saltar ‚¨ÜÔ∏è', canvas.width / 2, canvas.height / 2 + 5);
                ctx.fillText('o arrastra para pedo direccional üí®', canvas.width / 2, canvas.height / 2 + 25);
                ctx.textAlign = 'left';
            },
            
            drawPlayer() {
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                
                // Rotar seg√∫n la direcci√≥n del movimiento
                const moveAngle = Math.atan2(player.velocityY, player.velocityX + 0.5);
                ctx.rotate(moveAngle * 0.3);
                
                const offsetX = -player.width / 2;
                const offsetY = -player.height / 2;
                
                // Piernas
                ctx.strokeStyle = '#fcd34d';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(offsetX + 22, offsetY + 58);
                ctx.quadraticCurveTo(offsetX + 10, offsetY + 70, offsetX + 14, offsetY + 80);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(offsetX + 48, offsetY + 58);
                ctx.quadraticCurveTo(offsetX + 60, offsetY + 70, offsetX + 56, offsetY + 80);
                ctx.stroke();
                
                // Pies
                ctx.fillStyle = '#92400e';
                ctx.beginPath();
                ctx.ellipse(offsetX + 12, offsetY + 82, 6, 4, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(offsetX + 58, offsetY + 82, 6, 4, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Cuerpo
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.ellipse(offsetX + 35, offsetY + 45, 18, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Brazos
                ctx.strokeStyle = '#fcd34d';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(offsetX + 18, offsetY + 42);
                ctx.quadraticCurveTo(offsetX + 10, offsetY + 46, offsetX + 18, offsetY + 54);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(offsetX + 52, offsetY + 42);
                ctx.quadraticCurveTo(offsetX + 60, offsetY + 46, offsetX + 52, offsetY + 54);
                ctx.stroke();
                
                // Revista
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(offsetX + 14, offsetY + 44, 42, 28);
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(offsetX + 14, offsetY + 44, 42, 28);
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 7px Outfit';
                ctx.textAlign = 'center';
                ctx.fillText('ME', offsetX + 35, offsetY + 55);
                ctx.fillText('CAGO', offsetX + 35, offsetY + 65);
                ctx.textAlign = 'left';
                
                // Manos
                ctx.fillStyle = '#fcd34d';
                ctx.beginPath();
                ctx.arc(offsetX + 16, offsetY + 56, 5, 0, Math.PI * 2);
                ctx.arc(offsetX + 54, offsetY + 56, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Rostro
                const faceY = offsetY + 16;
                const faceX = offsetX + 35;
                const faceSize = 38;
                
                if (customFace) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(faceX, faceY, faceSize / 2, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(customFace, faceX - faceSize/2, faceY - faceSize/2, faceSize, faceSize);
                    ctx.restore();
                    
                    ctx.beginPath();
                    ctx.arc(faceX, faceY, faceSize / 2, 0, Math.PI * 2);
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    if (player.isDead) {
                        ctx.fillStyle = 'rgba(220, 38, 38, 0.6)';
                        ctx.beginPath();
                        ctx.arc(faceX, faceY, faceSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(faceX - 10, faceY - 6);
                        ctx.lineTo(faceX - 3, faceY + 1);
                        ctx.moveTo(faceX - 3, faceY - 6);
                        ctx.lineTo(faceX - 10, faceY + 1);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(faceX + 3, faceY - 6);
                        ctx.lineTo(faceX + 10, faceY + 1);
                        ctx.moveTo(faceX + 10, faceY - 6);
                        ctx.lineTo(faceX + 3, faceY + 1);
                        ctx.stroke();
                    }
                } else {
                    ctx.beginPath();
                    ctx.arc(faceX, faceY, faceSize / 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#fcd34d';
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    if (player.isDead) {
                        ctx.strokeStyle = '#dc2626';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(faceX - 10, faceY - 6);
                        ctx.lineTo(faceX - 3, faceY + 1);
                        ctx.moveTo(faceX - 3, faceY - 6);
                        ctx.lineTo(faceX - 10, faceY + 1);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(faceX + 3, faceY - 6);
                        ctx.lineTo(faceX + 10, faceY + 1);
                        ctx.moveTo(faceX + 10, faceY - 6);
                        ctx.lineTo(faceX + 3, faceY + 1);
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.ellipse(faceX - 7, faceY - 3, 6, 7, 0, 0, Math.PI * 2);
                        ctx.ellipse(faceX + 7, faceY - 3, 6, 7, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(faceX - 7, faceY - 4, 3, 0, Math.PI * 2);
                        ctx.arc(faceX + 7, faceY - 4, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#92400e';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(faceX - 12, faceY - 10);
                        ctx.lineTo(faceX - 3, faceY - 12);
                        ctx.moveTo(faceX + 3, faceY - 12);
                        ctx.lineTo(faceX + 12, faceY - 10);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(faceX - 7, faceY + 8);
                        ctx.quadraticCurveTo(faceX, faceY + 5, faceX + 7, faceY + 8);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#7dd3fc';
                        ctx.beginPath();
                        ctx.ellipse(faceX - 16, faceY - 3, 2, 4, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(248, 113, 113, 0.5)';
                        ctx.beginPath();
                        ctx.arc(faceX - 13, faceY + 3, 4, 0, Math.PI * 2);
                        ctx.arc(faceX + 13, faceY + 3, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            },
            
            drawFartClouds() {
                player.fartClouds.forEach(cloud => {
                    cloud.particles.forEach(p => {
                        const px = cloud.x + p.x;
                        const py = cloud.y + p.y;
                        ctx.beginPath();
                        ctx.arc(px, py, p.size * (cloud.size / 15), 0, Math.PI * 2);
                        const g = Math.floor(100 + Math.random() * 50);
                        ctx.fillStyle = `rgba(120, ${g}, 40, ${cloud.opacity * 0.6})`;
                        ctx.fill();
                    });
                });
            },
            
            drawObstacles() {
                pipes.forEach(pipe => {
                    if (pipe.isCheckpoint) {
                        this.drawCheckpointToilet(pipe);
                    } else {
                        this.drawBurningToilet(pipe);
                    }
                    this.drawIceStalactites(pipe);
                });
            },
            
            drawCheckpointToilet(pipe) {
                const toiletY = pipe.gapY + CONFIG.pipeGap;
                const toiletHeight = canvas.height - toiletY;
                const centerX = pipe.x + CONFIG.pipeWidth / 2;
                
                ctx.fillStyle = '#f8fafc';
                ctx.beginPath();
                ctx.moveTo(pipe.x - 4, toiletY + 30);
                ctx.lineTo(pipe.x + CONFIG.pipeWidth + 4, toiletY + 30);
                ctx.lineTo(pipe.x + CONFIG.pipeWidth, toiletY + toiletHeight);
                ctx.lineTo(pipe.x, toiletY + toiletHeight);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#f1f5f9';
                ctx.beginPath();
                ctx.ellipse(centerX, toiletY + 12, CONFIG.pipeWidth / 2 + 6, 16, 0, Math.PI, 0);
                ctx.fill();
                
                ctx.fillStyle = '#e2e8f0';
                ctx.beginPath();
                ctx.ellipse(centerX, toiletY + 16, CONFIG.pipeWidth / 2, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#cbd5e1';
                ctx.stroke();
                
                ctx.fillStyle = '#7dd3fc';
                ctx.beginPath();
                ctx.ellipse(centerX, toiletY + 18, CONFIG.pipeWidth / 3, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#10b981';
                ctx.font = 'bold 10px Outfit';
                ctx.textAlign = 'center';
                ctx.fillText('‚úì CHECK', centerX, toiletY + 45);
                ctx.textAlign = 'left';
                
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(centerX, toiletY - 8, 6 + Math.sin(animationTime * 3) * 2, 0, Math.PI * 2);
                ctx.fill();
            },
            
            drawBurningToilet(pipe) {
                const toiletY = pipe.gapY + CONFIG.pipeGap;
                const toiletHeight = canvas.height - toiletY;
                const centerX = pipe.x + CONFIG.pipeWidth / 2;
                
                ctx.fillStyle = '#f8fafc';
                ctx.beginPath();
                ctx.moveTo(pipe.x - 4, toiletY + 30);
                ctx.lineTo(pipe.x + CONFIG.pipeWidth + 4, toiletY + 30);
                ctx.lineTo(pipe.x + CONFIG.pipeWidth, toiletY + toiletHeight);
                ctx.lineTo(pipe.x, toiletY + toiletHeight);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#1c1917';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(pipe.x + 8 + i * 15, toiletY + 35 + (i % 2) * 8, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#f1f5f9';
                ctx.beginPath();
                ctx.ellipse(centerX, toiletY + 12, CONFIG.pipeWidth / 2 + 6, 16, 0, Math.PI, 0);
                ctx.fill();
                
                const seatGradient = ctx.createRadialGradient(centerX, toiletY + 16, 0, centerX, toiletY + 16, CONFIG.pipeWidth / 2);
                seatGradient.addColorStop(0, '#e2e8f0');
                seatGradient.addColorStop(0.7, '#f8fafc');
                seatGradient.addColorStop(1, '#4b5563');
                ctx.fillStyle = seatGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, toiletY + 16, CONFIG.pipeWidth / 2, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                
                const lavaGradient = ctx.createRadialGradient(centerX, toiletY + 18, 0, centerX, toiletY + 18, CONFIG.pipeWidth / 3);
                lavaGradient.addColorStop(0, '#fef08a');
                lavaGradient.addColorStop(0.5, '#f97316');
                lavaGradient.addColorStop(1, '#dc2626');
                ctx.fillStyle = lavaGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, toiletY + 18, CONFIG.pipeWidth / 3, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                this.drawFire(pipe.x, toiletY, CONFIG.pipeWidth);
            },
            
            drawFire(x, y, width) {
                for (let i = 0; i < 5; i++) {
                    const flameX = x + (width / 6) * (i + 1);
                    const flameOffset = Math.sin(animationTime * 4 + i * 1.5) * 4;
                    const flameHeight = 20 + Math.sin(animationTime * 6 + i * 2) * 8;
                    
                    ctx.fillStyle = 'rgba(220, 38, 38, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(flameX - 6, y + 12);
                    ctx.quadraticCurveTo(flameX + flameOffset, y - flameHeight, flameX + 6, y + 12);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(249, 115, 22, 0.85)';
                    ctx.beginPath();
                    ctx.moveTo(flameX - 4, y + 12);
                    ctx.quadraticCurveTo(flameX + flameOffset * 0.7, y - flameHeight * 0.7, flameX + 4, y + 12);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(251, 191, 36, 0.9)';
                    ctx.beginPath();
                    ctx.moveTo(flameX - 2, y + 12);
                    ctx.quadraticCurveTo(flameX + flameOffset * 0.4, y - flameHeight * 0.5, flameX + 2, y + 12);
                    ctx.fill();
                }
            },
            
            drawIceStalactites(pipe) {
                const iceEndY = pipe.gapY;
                
                const iceGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + CONFIG.pipeWidth, 0);
                iceGradient.addColorStop(0, '#a5f3fc');
                iceGradient.addColorStop(0.5, '#ecfeff');
                iceGradient.addColorStop(1, '#a5f3fc');
                ctx.fillStyle = iceGradient;
                ctx.fillRect(pipe.x, 0, CONFIG.pipeWidth, iceEndY - 30);
                
                ctx.strokeStyle = '#67e8f9';
                ctx.lineWidth = 2;
                ctx.strokeRect(pipe.x, 0, CONFIG.pipeWidth, iceEndY - 30);
                
                [0.15, 0.35, 0.5, 0.65, 0.85].forEach((pos, i) => {
                    const icicleX = pipe.x + CONFIG.pipeWidth * pos;
                    const icicleHeight = 20 + (i % 2) * 15 + Math.sin(animationTime + i) * 2;
                    
                    ctx.fillStyle = '#ecfeff';
                    ctx.beginPath();
                    ctx.moveTo(icicleX - 5, iceEndY - 30);
                    ctx.lineTo(icicleX + 5, iceEndY - 30);
                    ctx.lineTo(icicleX, iceEndY - 30 + icicleHeight);
                    ctx.closePath();
                    ctx.fill();
                });
            },
            
            drawMeltingDrops() {
                meltingDrops.forEach(drop => {
                    ctx.fillStyle = `rgba(30, 30, 30, ${drop.opacity})`;
                    ctx.beginPath();
                    ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        };

        // ===== L√ìGICA DEL JUEGO =====
        const Game = {
            init() {
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                document.getElementById('startScreen').classList.add('hidden');
                canvas.classList.remove('hidden');
                document.getElementById('gameUI').classList.remove('hidden');
                
                // Eventos de joystick
                canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                canvas.addEventListener('mouseup', () => this.handleEnd());
                canvas.addEventListener('mouseleave', () => this.handleEnd());
                
                canvas.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
                canvas.addEventListener('touchend', () => this.handleEnd(), { passive: false });
                canvas.addEventListener('touchcancel', () => this.handleEnd(), { passive: false });
                
                Cityscape.init();
                this.reset();
                gameState = 'ready';
                this.loop();
            },
            
            handleStart(e) {
                e.preventDefault();
                
                if (gameState === 'ready') {
                    this.startGame();
                    return;
                }
                
                if (gameState === 'playing' && !player.isDead) {
                    // Guardar posici√≥n y tiempo de inicio
                    touchStartTime = Date.now();
                    const coords = Joystick.getCanvasCoords(e);
                    touchStartPos = { x: coords.x, y: coords.y };
                    isTap = true;
                    Joystick.start(e);
                }
            },
            
            handleMove(e) {
                if (gameState !== 'playing' || player.isDead) return;
                
                // Si se movi√≥ m√°s de 15px, ya no es un tap
                if (joystick.active) {
                    const coords = Joystick.getCanvasCoords(e);
                    const dx = coords.x - touchStartPos.x;
                    const dy = coords.y - touchStartPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 15) {
                        isTap = false;
                    }
                }
                
                Joystick.move(e);
            },
            
            handleEnd() {
                if (gameState !== 'playing' || player.isDead) {
                    Joystick.end();
                    return;
                }
                
                const touchDuration = Date.now() - touchStartTime;
                
                // Si fue un toque corto (< 200ms) y no se movi√≥ mucho, es un tap simple
                if (isTap && touchDuration < 200 && joystick.power < 0.2) {
                    // Impulso simple hacia arriba
                    player.velocityY = -CONFIG.impulseForce * 0.8;
                    Audio.playFart();
                    
                    // Crear nube de pedo hacia abajo
                    player.fartClouds.push({
                        x: player.x + player.width / 2,
                        y: player.y + player.height,
                        angle: Math.PI / 2,
                        size: 20,
                        opacity: 1,
                        particles: Array.from({length: 8}, () => ({
                            x: 0,
                            y: 0,
                            size: 5 + Math.random() * 10,
                            speed: 2 + Math.random() * 3,
                            angle: Math.PI / 2 + (Math.random() - 0.5) * 0.5
                        }))
                    });
                    
                    joystick.active = false;
                    joystick.visible = false;
                } else {
                    // Usar joystick normalmente
                    Joystick.end();
                }
                
                isTap = false;
            },
            
            resizeCanvas() {
                const margin = 16;
                const availableWidth = window.innerWidth - margin * 2;
                const availableHeight = window.innerHeight - margin * 2;
                const gameRatio = 2 / 3;
                
                let displayWidth, displayHeight;
                if (availableWidth / availableHeight > gameRatio) {
                    displayHeight = availableHeight;
                    displayWidth = displayHeight * gameRatio;
                } else {
                    displayWidth = availableWidth;
                    displayHeight = displayWidth / gameRatio;
                }
                
                canvas.width = 400;
                canvas.height = 600;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                canvas.style.position = 'fixed';
                canvas.style.top = '50%';
                canvas.style.left = '50%';
                canvas.style.transform = 'translate(-50%, -50%)';
            },
            
            reset() {
                player.x = -80;
                player.y = canvas.height - 140;
                player.velocityX = 0;
                player.velocityY = 0;
                player.rotation = 0;
                player.isDead = false;
                player.fartClouds = [];
                
                pipes = [];
                meltingDrops = [];
                score = 0;
                level = 1;
                totalPipesPassed = 0;
                pipeCounter = 0;
                lastPipeSpawn = 0;
                animationTime = 0;
                
                CONFIG.pipeSpeed = CONFIG.initialSpeed;
                CONFIG.baseSpeed = CONFIG.initialSpeed;
                CONFIG.gravity = CONFIG.baseGravity;
                CONFIG.impulseForce = CONFIG.baseImpulse;
                
                doorAnimation = { active: false, progress: 0, doorOpen: 0, playerEntered: false };
                joystick.active = false;
                joystick.visible = false;
                
                document.getElementById('scoreDisplay').textContent = '0';
                LevelSystem.updateDisplay();
            },
            
            startGame() {
                gameState = 'starting';
                doorAnimation.active = true;
                Audio.playDoorOpen();
            },
            
            update() {
                animationTime += 0.1;
                
                Cityscape.update();
                
                // Actualizar nubes de pedo con direcci√≥n
                player.fartClouds.forEach(cloud => {
                    cloud.opacity -= 0.025;
                    cloud.size += 0.3;
                    cloud.particles.forEach(p => {
                        p.x += Math.cos(p.angle) * p.speed;
                        p.y += Math.sin(p.angle) * p.speed;
                    });
                });
                player.fartClouds = player.fartClouds.filter(c => c.opacity > 0);
                
                meltingDrops.forEach(drop => {
                    drop.y += drop.speed;
                    drop.opacity -= 0.01;
                });
                meltingDrops = meltingDrops.filter(d => d.opacity > 0 && d.y < canvas.height);
                
                if (gameState === 'starting') {
                    this.updateDoorAnimation();
                    return;
                }
                
                if (gameState !== 'playing' || player.isDead) return;
                
                // F√≠sica del jugador con movimiento 2D
                player.velocityY += CONFIG.gravity;
                player.velocityX *= 0.98; // Fricci√≥n horizontal
                
                player.x += player.velocityX;
                player.y += player.velocityY;
                
                // Mantener al jugador en la zona de juego horizontalmente
                player.x = Math.max(50, Math.min(canvas.width * 0.4, player.x));
                
                // Spawn de obst√°culos
                const now = Date.now();
                if (now - lastPipeSpawn > CONFIG.spawnInterval) {
                    this.spawnPipe();
                    lastPipeSpawn = now;
                }
                
                // Mover obst√°culos
                pipes.forEach(pipe => {
                    pipe.x -= CONFIG.pipeSpeed;
                    
                    if (!pipe.scored && pipe.x + CONFIG.pipeWidth < player.x) {
                        score++;
                        totalPipesPassed++;
                        pipe.scored = true;
                        document.getElementById('scoreDisplay').textContent = score;
                        LevelSystem.checkLevelUp();
                    }
                    
                    if (!pipe.isCheckpoint && Math.random() < 0.02) {
                        meltingDrops.push({
                            x: pipe.x + Math.random() * CONFIG.pipeWidth,
                            y: pipe.gapY + CONFIG.pipeGap + 15,
                            speed: 2 + Math.random() * 2,
                            size: 2 + Math.random() * 2,
                            opacity: 1
                        });
                    }
                });
                
                pipes = pipes.filter(p => p.x > -CONFIG.pipeWidth);
                
                this.checkCollisions();
            },
            
            updateDoorAnimation() {
                doorAnimation.progress += 0.025;
                
                if (doorAnimation.progress < 0.4) {
                    doorAnimation.doorOpen = doorAnimation.progress / 0.4;
                } else if (!doorAnimation.playerEntered) {
                    doorAnimation.playerEntered = true;
                    player.x = 50;
                    player.y = canvas.height - 140;
                }
                
                if (doorAnimation.playerEntered) {
                    player.x += 1.5;
                    
                    if (player.x >= 80) {
                        gameState = 'playing';
                        player.x = 80;
                        player.y = 280;
                        lastPipeSpawn = Date.now();
                    }
                }
            },
            
            spawnPipe() {
                const minGapY = 100;
                const maxGapY = canvas.height - CONFIG.pipeGap - 100;
                const gapY = minGapY + Math.random() * (maxGapY - minGapY);
                
                pipeCounter++;
                pipes.push({
                    x: canvas.width,
                    gapY: gapY,
                    scored: false,
                    isCheckpoint: LevelSystem.isCheckpoint(pipeCounter),
                    pipeNumber: pipeCounter
                });
            },
            
            checkCollisions() {
                if (player.y < 0 || player.y + player.height > canvas.height - 15) {
                    this.die();
                    return;
                }
                
                const box = {
                    x: player.x + 12,
                    y: player.y + 10,
                    width: player.width - 24,
                    height: player.height - 20
                };
                
                for (const pipe of pipes) {
                    if (this.rectCollision(box, { x: pipe.x, y: 0, width: CONFIG.pipeWidth, height: pipe.gapY }) ||
                        this.rectCollision(box, { x: pipe.x, y: pipe.gapY + CONFIG.pipeGap, width: CONFIG.pipeWidth, height: canvas.height })) {
                        this.die();
                        return;
                    }
                }
            },
            
            rectCollision(a, b) {
                return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
            },
            
            die() {
                player.isDead = true;
                Audio.playDeath();
                
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        player.fartClouds.push({
                            x: player.x + player.width / 2,
                            y: player.y + player.height / 2,
                            angle: angle,
                            size: 30 + i * 10,
                            opacity: 1,
                            particles: Array.from({length: 10}, () => ({
                                x: 0,
                                y: 0,
                                size: 8 + Math.random() * 15,
                                speed: 2 + Math.random() * 3,
                                angle: angle + (Math.random() - 0.5) * 1
                            }))
                        });
                    }, i * 80);
                }
                
                setTimeout(() => {
                    gameState = 'gameover';
                    this.showGameOver();
                }, 1000);
            },
            
            showGameOver() {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('flappyPedoHighScore', highScore);
                }
                
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalLevel').textContent = level;
                document.getElementById('highScore').textContent = highScore;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            },
            
            render() {
                Renderer.drawBackground();
                
                if (gameState === 'ready' || gameState === 'starting') {
                    Renderer.drawDoor();
                }
                
                Renderer.drawObstacles();
                Renderer.drawMeltingDrops();
                Renderer.drawFartClouds();
                
                if (gameState !== 'ready' || doorAnimation.playerEntered) {
                    Renderer.drawPlayer();
                }
                
                // Dibujar joystick
                Joystick.draw();
                
                if (gameState === 'ready') {
                    Renderer.drawReadyMessage();
                }
            },
            
            loop() {
                this.update();
                this.render();
                animationId = requestAnimationFrame(() => this.loop());
            }
        };

        // ===== INICIALIZACI√ìN =====
        document.addEventListener('DOMContentLoaded', () => {
            ImageCropper.init();
            
            const fartButtons = document.querySelectorAll('.fart-btn');
            fartButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    fartButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedFart = btn.dataset.fart;
                });
            });
            
            document.getElementById('testFartBtn').addEventListener('click', () => {
                Audio.playFart(selectedFart);
            });
            
            document.getElementById('startBtn').addEventListener('click', () => Game.init());
            
            document.getElementById('restartBtn').addEventListener('click', () => {
                document.getElementById('gameOverScreen').classList.add('hidden');
                Game.reset();
                gameState = 'ready';
            });
            
            document.getElementById('menuBtn').addEventListener('click', () => {
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('gameUI').classList.add('hidden');
                canvas.classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                gameState = 'menu';
                if (animationId) cancelAnimationFrame(animationId);
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (gameState === 'ready') Game.startGame();
                }
            });
            
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) e.preventDefault();
                lastTouchEnd = now;
            }, { passive: false });
            
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) e.preventDefault();
            }, { passive: false });
        });
    </script>
</body>
</html>
